# STL

## STL

- standard template library
- 크게 3가지로 나눌 수 있음

1. 컨테이너: 데이터를 담을 수 있음
2. 알고리즘: 데이터를 처리하고 제어할 수 있는 여러 알고리즘
3. 반복자(iterator): 컨테이너에 접근 및 순회할 수 있게 함

## STL과 같이 자주 사용하는 문법

### 상수 레퍼런스

값에 의한 호출(call by value)

- C++ 에서는 함수의 인수로 값을 전달할 때 값을 복사
- 함수가 호출될 때 마다 복사 발생
- 만약, 복사 크기가 커지면 성능에 영향을 미칠 수 있음

```c++
#include <iostream>

using namespace std;

void modify(int value) {
  value = 10;
  cout << "주소 " << &value << endl; // 0x16f74761c (3)
  cout << "값: " << value << endl; // 10 (4)
  // 함수가 종료되면 value 변수는 메모리에서 사라짐
}

int main() {
  int value = 5;
  cout << "주소: " << &value << endl; // 0x16f747658 (1)
  cout << "값: " << value << endl; // 5 (2)
  modify(value);
  // 원본 value는 변화 없음
  cout << "값: " << value << endl; // 5 (5)

  return 0;
}

```

참조에 의한 호출(call by reference)

- 함수의 인수로 넘기는 변수를 함수 내부에서 바꾸고 싶을 때
- 변수 복사가 일어나지 않고, 참조자(레퍼런스)를 통해 변수에 접근하고 수정

```c++
#include <iostream>

using namespace std;

void modify(int &value) {
  value = 10;
  // value의 메모리 주소 동일
  cout << "주소 " << &value << endl; // 0x16f053658 (3)
  cout << "값: " << value << endl; // 10 (4)
  // 함수가 종료되면 value 변수는 메모리에서 사라짐
}

int main() {
  int value = 5;
  // value의 메모리 주소 동일
  cout << "주소: " << &value << endl; // 0x16f053658 (1)
  cout << "값: " << value << endl; // 5 (2)
  modify(value);
  // 원본 value가 변경됨
  cout << "값: " << value << endl; // 10 (5)

  return 0;
}

```

참조값(레퍼런스) 전달 vs 주소값(포인터) 전달

공통점

- 변수 원본 변경 가능

차이점

- 참조값 전달 시 참조 변수와 참조 대상 변수의 주소값이 일치하므로 메모리 값 읽는 추가 작업 불필요
- 주소값 전달 시 주소값 변수와 실제 변수의 주소값이 다르기 때문에 포인터 변수 사용해야 함
    - 포인터 사용 시 잘못된 주소에 접근할 우려가 있음

레퍼런스 전달 방식이 더 간편