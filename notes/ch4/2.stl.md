# STL

## STL

- standard template library
- 크게 3가지로 나눌 수 있음

1. 컨테이너: 데이터를 담을 수 있음
2. 알고리즘: 데이터를 처리하고 제어할 수 있는 여러 알고리즘
3. 반복자(iterator): 컨테이너에 접근 및 순회할 수 있게 함

## STL과 같이 자주 사용하는 문법

### 상수 레퍼런스

값에 의한 호출(call by value)

- C++ 에서는 함수의 인수로 값을 전달할 때 값을 복사
- 함수가 호출될 때 마다 복사 발생
- 만약, 복사 크기가 커지면 성능에 영향을 미칠 수 있음

```c++
#include <iostream>

using namespace std;

void modify(int value) {
  value = 10;
  cout << "주소 " << &value << endl; // 0x16f74761c (3)
  cout << "값: " << value << endl; // 10 (4)
  // 함수가 종료되면 value 변수는 메모리에서 사라짐
}

int main() {
  int value = 5;
  cout << "주소: " << &value << endl; // 0x16f747658 (1)
  cout << "값: " << value << endl; // 5 (2)
  modify(value);
  // 원본 value는 변화 없음
  cout << "값: " << value << endl; // 5 (5)

  return 0;
}

```

참조에 의한 호출(call by reference)

- 함수의 인수로 넘기는 변수를 함수 내부에서 바꾸고 싶을 때
- 변수 복사가 일어나지 않고, 참조자(레퍼런스)를 통해 변수에 접근하고 수정

```c++
#include <iostream>

using namespace std;

void modify(int &value) {
  value = 10;
  // value의 메모리 주소 동일
  cout << "주소 " << &value << endl; // 0x16f053658 (3)
  cout << "값: " << value << endl; // 10 (4)
  // 함수가 종료되면 value 변수는 메모리에서 사라짐
}

int main() {
  int value = 5;
  // value의 메모리 주소 동일
  cout << "주소: " << &value << endl; // 0x16f053658 (1)
  cout << "값: " << value << endl; // 5 (2)
  modify(value);
  // 원본 value가 변경됨
  cout << "값: " << value << endl; // 10 (5)

  return 0;
}

```

참조값(레퍼런스) 전달 vs 주소값(포인터) 전달

공통점

- 변수 원본 변경 가능

차이점

- 참조값 전달 시 참조 변수와 참조 대상 변수의 주소값이 일치하므로 메모리 값 읽는 추가 작업 불필요
- 주소값 전달 시 주소값 변수와 실제 변수의 주소값이 다르기 때문에 포인터 변수 사용해야 함
    - 포인터 사용 시 잘못된 주소에 접근할 우려가 있음

레퍼런스 전달 방식이 더 간편

### auto 문

- 어떤 타입에도 사용 가능
- 변수 타입을 자동으로 추론
    - 코드 간결해지고 유지보수 쉬워짐

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main() {
  auto num = 42;
  cout << num << endl;

  auto pi = 3.141592;
  cout << pi << endl;

  auto greeting = string("Hello, worild!");
  cout << greeting << endl;

  return 0;
}

```

### 범위 기반 반복문

- 배열이나 컨테이너의 모든 원소 순회 시 사용
- 기본 반복문보다 쉽고 가독성 좋음

```c++
#include <iostream>
#include <vector>
#include <map>
#include <set>

using namespace std;


int main() {
  vector<int> vec = {1, 2, 3, 4, 5};
  for (int num: vec) {
    cout << num << " "; // 1 2 3 4 5
  }
  cout << endl;

  // map
  map<string, int> fruitMap = {{"apple", 1}, {"banana", 2}, {"cherry", 3}};
  // 값 수정 X이고
  // 복사 비용을 고려하여 상수 레퍼런스 전달
  for (const auto &pair: fruitMap) {
    cout << pair.first << "=" << pair.second << " "; // apple=1 banana=2 cherry=3
  }
  cout << endl;

  // set
  set<string> fruitSet = {"apple", "banana", "cherry"};
  cout << "Set: ";
  for (const auto &fruit: fruitSet) {
    cout << fruit << " "; // apple banana cherry 
  }

  return 0;
}

```
