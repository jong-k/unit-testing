# STL

## STL

- standard template library
- 크게 3가지로 나눌 수 있음

1. 컨테이너: 데이터를 담을 수 있음
2. 알고리즘: 데이터를 처리하고 제어할 수 있는 여러 알고리즘
3. 반복자(iterator): 컨테이너에 접근 및 순회할 수 있게 함

## STL과 같이 자주 사용하는 문법

### 상수 레퍼런스

값에 의한 호출(call by value)

- C++ 에서는 함수의 인수로 값을 전달할 때 값을 복사
- 함수가 호출될 때 마다 복사 발생
- 만약, 복사 크기가 커지면 성능에 영향을 미칠 수 있음

```c++
#include <iostream>

using namespace std;

void modify(int value) {
  value = 10;
  cout << "주소 " << &value << endl; // 0x16f74761c (3)
  cout << "값: " << value << endl; // 10 (4)
  // 함수가 종료되면 value 변수는 메모리에서 사라짐
}

int main() {
  int value = 5;
  cout << "주소: " << &value << endl; // 0x16f747658 (1)
  cout << "값: " << value << endl; // 5 (2)
  modify(value);
  // 원본 value는 변화 없음
  cout << "값: " << value << endl; // 5 (5)

  return 0;
}

```

참조에 의한 호출(call by reference)

- 함수의 인수로 넘기는 변수를 함수 내부에서 바꾸고 싶을 때
- 변수 복사가 일어나지 않고, 참조자(레퍼런스)를 통해 변수에 접근하고 수정

```c++
#include <iostream>

using namespace std;

void modify(int &value) {
  value = 10;
  // value의 메모리 주소 동일
  cout << "주소 " << &value << endl; // 0x16f053658 (3)
  cout << "값: " << value << endl; // 10 (4)
  // 함수가 종료되면 value 변수는 메모리에서 사라짐
}

int main() {
  int value = 5;
  // value의 메모리 주소 동일
  cout << "주소: " << &value << endl; // 0x16f053658 (1)
  cout << "값: " << value << endl; // 5 (2)
  modify(value);
  // 원본 value가 변경됨
  cout << "값: " << value << endl; // 10 (5)

  return 0;
}

```

참조값(레퍼런스) 전달 vs 주소값(포인터) 전달

공통점

- 변수 원본 변경 가능

차이점

- 참조값 전달 시 참조 변수와 참조 대상 변수의 주소값이 일치하므로 메모리 값 읽는 추가 작업 불필요
- 주소값 전달 시 주소값 변수와 실제 변수의 주소값이 다르기 때문에 포인터 변수 사용해야 함
    - 포인터 사용 시 잘못된 주소에 접근할 우려가 있음

레퍼런스 전달 방식이 더 간편

### auto 문

- 어떤 타입에도 사용 가능
- 변수 타입을 자동으로 추론
    - 코드 간결해지고 유지보수 쉬워짐

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main() {
  auto num = 42;
  cout << num << endl;

  auto pi = 3.141592;
  cout << pi << endl;

  auto greeting = string("Hello, worild!");
  cout << greeting << endl;

  return 0;
}

```

### 범위 기반 반복문

- 배열이나 컨테이너의 모든 원소 순회 시 사용
- 기본 반복문보다 쉽고 가독성 좋음

```c++
#include <iostream>
#include <vector>
#include <map>
#include <set>

using namespace std;


int main() {
  vector<int> vec = {1, 2, 3, 4, 5};
  for (int num: vec) {
    cout << num << " "; // 1 2 3 4 5
  }
  cout << endl;

  // map
  map<string, int> fruitMap = {{"apple", 1}, {"banana", 2}, {"cherry", 3}};
  // 값 수정 X이고
  // 복사 비용을 고려하여 상수 레퍼런스 전달
  for (const auto &pair: fruitMap) {
    cout << pair.first << "=" << pair.second << " "; // apple=1 banana=2 cherry=3
  }
  cout << endl;

  // set
  set<string> fruitSet = {"apple", "banana", "cherry"};
  cout << "Set: ";
  for (const auto &fruit: fruitSet) {
    cout << fruit << " "; // apple banana cherry 
  }

  return 0;
}

```

## 반복자(iterator)

- 컨테이너(벡터, 셋, 맵 등)의 종류와 관계 없이 같은 방식으로 원소들을 순회하고 접근할 수 있게 해줌

### 순방향 반복자(forward iterator)

begin(), end() 를 함께 사용

- begin(): 컨테이너의 첫 번째 원소
- end(): 컨테이너의 마지막 원소의 다음 위치

vector 순회 및 탐색

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
  vector<int> vec = {10, 20, 30, 40, 50};

  // 순회하고 출력
  // 1. 범위 기반 for loop
  for (int it: vec) {
    cout << it << " "; // 10 20 30 40 50
  }
  cout << endl;
  // 2. 이터레이터(1번과 동일)
  for (auto it = vec.begin(); it != vec.end(); ++it) {
    // 이터레이터의 실제값을 참조하려면 *를 붙임
    cout << *it << " "; // 10 20 30 40 50
  }
  cout << endl;

  // 탐색
  auto result = find(vec.begin(), vec.end(), 30);
  if (result != vec.end()) {
    cout << "Found: " << *result << endl; // Found: 30
  } else {
    cout << "Not Found" << endl;
  }

  return 0;
}

```

map 순회 및 탐색

```c++
#include <iostream>
#include <map>

using namespace std;

int main() {
  map<string, int> myMap = {{"apple", 1}, {"banana", 2}, {"cherry", 3}};
  /* 아래 키-밸류 구조와 같음
   * apple: 1
   * banana: 2
   * cherry: 3
   */

  // 순회 및 출력
  for (auto &it: myMap) {
    cout << it.first << ": " << it.second << endl;
  }
  cout << endl;
  for (auto it = myMap.begin(); it != myMap.end(); ++it) {
    cout << it->first << ": " << it->second << endl;
  }
  cout << endl;
  // 원소 탐색
  auto result = myMap.find("banana");
  if (result != myMap.end()) {
    cout << "Found: " << result->first << " -> " << result->second << endl; // Found: banana -> 2
  } else {
    cout << "Not found" << endl;
  }
  return 0;
}

```